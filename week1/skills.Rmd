---
title: "Skills: Displaying map data"
subtitle: "Week 1"
output: 
  rmdformats::readthedown:
    toc_depth: 3
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
#knitr::knit_engines$set(python = reticulate::eng_python) 
```

This page introduces useful skills for displaying
geospatial data on a map using R, QGIS, or ArcGIS.

The R skills on this page use the following R packages:

```{r, message=FALSE, warning=FALSE}
library(tigris)
library(rnaturalearth)
library(sf)
library(here)
library(tidyverse)
library(leaflet)
library(ggspatial)
library(ggthemes)
library(htmlwidgets)
library(here)
library(RColorBrewer)
library(crsuggest)
```

# Loading data

A first step in working with geospatial data is loading it into 
the software you are working with.

## R

Some packages (such as the `tigris` package) will load data
directly from an online source (so you need to be connected to the 
internet for these functions to work). 

```{r, results='hide', message=FALSE}
states <- states()
rails <- rails()
TX_landmarks <- landmarks(state = "TX")
```

Other packages (such as `rnaturalearth`) include geospatial datasets (the
data was installed on your computer along with the package, so they will
work regardless of whether you are connected to the internet).

```{r, message=FALSE, results='hide'}
library(rnaturalearth)

africa <- ne_countries(continent = "Africa", returnclass = "sf")
```


The `st_read` funtion (from the `sf` package) will read
data from a file in any common data format. 

```{r, results='hide', message=FALSE}
library(sf)
library(here)

open_space <- here("week1",
                   "data",
                   "Open_Space.geojson") |>
  st_read()
```

For shapefiles, use the name of the directory containing the set of 
files.

```{r, results='hide'}
community_c <- here("week1",
                    "data",
                    "Community_Centers") |>
  st_read()
```

## QGIS

In QGIS, you can load a layer by dragging and dropping it into 
the main window. This can be either a single geospatial file (like
a geojson file or a kml file) or a directory containing a shapefile (along
with its associated files).

Once the dataset is loaded in QGIS, you'll see it listed in your
layers panel and displayed in the map panel.

```{r, echo=FALSE, out.width = '100%'}
here("week1",
     "examples",
     "qgis-gifs",
     "load-layers.gif") |>
  knitr::include_graphics()
```

## ArcGIS

In ArcGIS Pro, click on the "Add Data" button on the Map tab, navigate to the 
shapefile you want to load, and select OK.

Once the dataset is loaded in ArcGIS, you'll see it listed in your
contents panel and displayed in the map panel.

```{r, echo=FALSE, out.width = '100%'}
here("week1",
     "examples",
     "arcgis-gifs",
     "load-shp.gif") |>
  knitr::include_graphics()
```

# Filtering data by attribute

You may have loaded a set of features that includes some categories
you aren't interested in. 

## R

You can use the `filter` function to filter based on the value
of a variable.

```{r}
texas <- states |>
  filter(NAME == "Texas")

washington <- states |>
  filter(NAME == "Washington")

contig_states <- states |>
  filter(STUSPS != "AK" &
           STUSPS != "PR" &
           STUSPS != "AS" &
           STUSPS != "MP" &
           STUSPS != "VI" &
           STUSPS != "HI" &
           STUSPS != "GU")

TX_cemeteries <- TX_landmarks |>
  filter(MTFCC == "K2582")

TX_golf <- TX_landmarks |>
  filter(MTFCC == "K2561")
```


## QGIS

In QGIS, you'll do this in two steps. First, you'll select features
based on an attribute value. 

```{r, echo=FALSE, out.width = '100%'}
here("week1",
     "examples",
     "qgis-gifs",
     "select-by-attr.gif") |>
  knitr::include_graphics()
```

Then, you'll export your selection as a new layer.

```{r, echo=FALSE, out.width = '100%'}
here("week1",
     "examples",
     "qgis-gifs",
     "exp-select.gif") |>
  knitr::include_graphics()
```

## ArcGIS Pro

In ArcGIS, you can apply a filter while exporting features.

```{r, echo=FALSE, out.width = '100%'}
here("week1",
     "examples",
     "arcgis-gifs",
     "exp-filter.gif") |>
  knitr::include_graphics()
```

# Filtering data by location

You may have loaded data for a large area, and you're only interested 
in the features within a smaller area. 

## R

You can use `st_filter` to keep only the features within
a polygon.

```{r}
TX_rails <- rails |>
  st_filter(texas)
```


## QGIS

In QGIS, you can select features based on their location within
a polygon.

```{r, echo=FALSE, out.width = '100%'}
here("week1",
     "examples",
     "qgis-gifs",
     "sp-filter.gif") |>
  knitr::include_graphics()
```

Then export the selection.

```{r, echo=FALSE, out.width = '100%'}
here("week1",
     "examples",
     "qgis-gifs",
     "exp-select.gif") |>
  knitr::include_graphics()
```

## ArcGIS

In ArcGIS, you can select features based on their location within
a polygon.

```{r, echo=FALSE, out.width = '100%'}
here("week1",
     "examples",
     "arcgis-gifs",
     "sp-filter.gif") |>
  knitr::include_graphics()
```

Then export the selection.

```{r, echo=FALSE, out.width = '100%'}
here("week1",
     "examples",
     "arcgis-gifs",
     "save-select.gif") |>
  knitr::include_graphics()
```

# Viewing data in a map

It can be helpful to take an initial look at your data on a map. ArcGIS
and QGIS will display your data in a map panel when you load it. In R, you'll need to create some kind of plot to visualize your data.

## R (interactive)

The `leaflet` package in R can create interactive, html-based maps. These
can be useful for exploring your data even if you ultimately want to be
producing a static map. You can read about `leaflet` here: https://rstudio.github.io/leaflet/

Set up the leaflet map with a call to the `leaflet()` function. Use the 
`addTiles()` function if you want to display your data over a default
OpenStreetMap base map. Then use `addPolygons()` to add polygon data,
`addPolylines()` to add line data, or `addCircleMarkers()` to add point
data.

A useful trick if you just want to explore your data is to specify a 
popup that will give you the value of a variable when you click on 
a feature.

```{r, warning=FALSE}
leaflet() |>
  addTiles() |>
  addPolygons(data = texas, 
              popup = ~NAME) |>
  addPolylines(data = TX_rails, 
               popup = ~FULLNAME, 
               color = "red") |>
  addCircleMarkers(data = TX_cemeteries,
                   popup = ~FULLNAME,
                   color = "black") 
```

## R (static)

You can also make a quick static plot of a dataset using `ggplot`.

```{r}
ggplot(texas) +
  geom_sf() +
  geom_sf(data = TX_rails,
          color = "red")
```


# Choosing and changing a map projection

All Census TIGER files are in a geographic coordinate system (meaning
coordinates are stored as latitude/longitude coordinates) called NAD 83.

By default, having your data stored in a geographic coordinate system will mean
it is displayed some kind of Mercator projection by default. In the northern 
parts of the United States, this may make your map look a little distorted and 
you may want to change what projection is used to display your data.



## R

R has a handy package called `crsuggest` that will suggest an appropriate 
projection for a spatial dataset. The most useful function in this package is
called `suggest_crs`. It will return a table of potential coordinate reference
systems you can use. 

```{r}
new_crs <- suggest_crs(contig_states)

new_crs
```



## QGIS

In QGIS

# Setting the map projection

All Census TIGER files are in a geographic coordinate system (meaning
coordinates are stored as latitude/longitude coordinates) called NAD 83.

By default, having your data stored in a geographic coordinate system will mean
it is displayed some kind of Mercator projection by default. In the northern 
parts of the United States, this may make your map look a little distorted and 
you may want to change what projection is used to display your data.

Which map projection should you use? If you are working in the United States 
and your map is of a region the size of a small or medium-size state, a good
option would be a state plane coordinate system. State plane coordinate systems have coordinates
in units of feet. One way to find suggestions for appropriate coordinate 
reference systems is to go to https://spatialreference.org/, where you can search for a 
particular geography.

Each software program also has some ability to search for a coordinate reference
system (R has a particularly handy method for this).

## R (interactive)

You can't change the projection on an interactive leaflet map. All maps are 
projected in Web Mercator, which is standard for web-based maps.

## R (static)

Here is are the contiguous United States in a ggplot with a Mercator projection.

```{r}
ggplot(contig_states) +
  geom_sf() +
  theme_void()
```

R has a handy package called `crsuggest` that will suggest an appropriate 
projection for a spatial dataset. The most useful function in this package is
called `suggest_crs`. It will return a table of potential coordinate reference
systems you can use. 

```{r}
new_crs <- suggest_crs(contig_states)

new_crs
```

I'll use the first one on the list. I can use the `coord_sf` function to set the 
`crs` parameter using the crs_code from the above table.


```{r}
ggplot(contig_states) +
  geom_sf() +
  coord_sf(crs = 6350) +
  theme_void()
```

## QGIS

Click on the button on the bottom right corner of your map window that 
shows the current projection, and select a new projection. You can
select from a list of recently-used projections, or from a longer
list of pre-defined projections. You can use the search bar to search
for a projection by name.

In this example, I'm reprojecting from the WGS 84 to 
the Washington State Plane (North) CRS. You can search for a state plane 
CRS by typing the name of the state in the search bar and then finding
it in the "Predefined Coordinate Reference Systems" box under 
"Projected" and "Lambert Conformal Conic" (most state plane systems
are of the Lambert Conformal Conic type). 

If this is a 
reprojection you haven't done before, 
you might see a dialog asking you to select a transformation method.
In this case, you can just accept the default.

```{r, echo=FALSE, message=FALSE, out.width = '100%'}
here("week1",
     "examples",
     "qgis-gifs",
     "projection.gif") |>
  knitr::include_graphics()
```

## ArcGIS

You can change the map's coordinate system from the Map Properties window,
under "Coordinate System."

To find a state plan coordinate system, serach for the name of the state, 
and then find it in the "XY Coordinate Systems Available" box under 
"Projected Coordinate System", then "State Plane", then "NAD 1983 (2011) (US feet)".

```{r, echo=FALSE, message=FALSE, out.width = '100%'}
here("week1",
     "examples",
     "qgis-gifs",
     "projection-arc.gif") |>
  knitr::include_graphics()
```

# Setting symbology by layer

You can control the appearance of features on your map by
defining some of the following attributes

* Polygons
    * Fill color
    * Fill opacity
    * Fill pattern
    * Line color
    * Line opacity
    * Line weight
* Lines
    * Color
    * Opacity
    * Weight
* Points
    * Size
    * Shape
    * Color
    * Opacity
    
## R (interactive)

In `leaflet`, `addPolygons` and `addCircleMarkers` have the following optional arguments:

* `stroke` controls whether there will be a line border around the polygon. 
The default is `TRUE`.
* `fill` controls whether the polygon will be filled. The default is `TRUE`.
If you set both `stroke` and `fill` to false, the polygon will be invisible.
* `color` controls the color of the border.
* `opacity` controls the transparency/opacity of the border. It ranges from 0 to 1, where 1 is
fully opaque and 0 is fully transparent.
* `weight` controls the line weight of the border. 
* `fillColor` controls the fill color.
* `fillOpacity` controls the fill opacity. It ranges from 0 to 1, where 1 is
fully opaque and 0 is fully transparent.

In addition, `addCircleMarkers` has an argument for `radius` that controls
the size of the circles.

`addPolylines` has optional arguments for `color`, `opacity`, and `weight`.

```{r, warning=FALSE}
leaflet() |>
  addPolygons(data = texas, 
              popup = ~NAME,
              stroke = FALSE,
              fillOpacity = 1,
              fillColor = "white") |>
  addPolylines(data = TX_rails, 
               popup = ~FULLNAME, 
               color = "gray",
               weight = 1,
               opacity = 1) |>
  addCircleMarkers(data = TX_cemeteries,
                   popup = ~FULLNAME,
                   color = "black",
                   radius = 0.5,
                   opacity = 1) 
```

## R (static)

In `ggplot`, you can set the following optional arguments in the
`geom_sf` function:

* `color` sets the color of a point or a line, or the outline
color of a polygon (set `color = NA` for a polygon with no outline).
* `fill` sets the fill color of a polygon (set `fill = NA` for 
a polygon with no fill).
* `alpha` sets the transparency of a feature. It ranges from 0 to 1, where 1 is
fully opaque and 0 is fully transparent.
* `linewidth` sets the weight of a line (or the outline of a polygon).
* `linetype` sets the style of a line. Options include:
    * `solid`
    * `longdash`
    * `dotted`
    * `dotdash`
    * `dashed`
* `size` sets the size of a point
* `shape` sets the shape of a point. The most common options are 
indicated by numbers 0 through 25. Common options include
    * 20 for a small, filled circle
    * 15 for a square
    * 17 for a triangle
    * 18 for a diamond

```{r}
ggplot() +
  geom_sf(data = texas,
          color = NA,
          fill = "cornsilk") +
  geom_sf(data = TX_rails,
          color = "black",
          linewidth = 0.5,
          linetype = "dotted") +
  geom_sf(data = TX_cemeteries,
          size = 4,
          shape = 18,
          color = "darkgreen",
          alpha = 0.5)
  
```



## QGIS

In QGIS, you can get to the options to change your feature symbology
by double-clicking on the symbol in the layers panel, then selecting
the tab with an icon that looks like a little paint brush.

```{r, echo=FALSE, out.width = '100%'}
here("week1",
     "examples",
     "qgis-gifs",
     "symbols.gif") |>
  knitr::include_graphics()
```

## ArcGIS

In ArcGIS, you can change the symbology of a layer by double-clicking
the symbol in the contents pane.

```{r, echo=FALSE, out.width = '100%'}
here("week1",
     "examples",
     "arcgis-gifs",
     "symbols.gif") |>
  knitr::include_graphics()
```

# Setting symbology by attribute

You might want to vary the display of features in a layer, depending on
the values of a variable.

## R (interactive)

In `leaflet`, you'll need to start by defining a color palette that 
will be mapped to a variable. The `RColorBrewer` package has some 
nice, pre-defined (and colorblind-friendly) color palettes you
can choose from. These are shown below.

```{r, fig.height=8, echo=FALSE}
RColorBrewer::display.brewer.all()
```

Use the `colorNumeric()` function to map a palette to a continuous variable or 
`colorFactor()` to map a palette to a categorical variable.

```{r}
owner_pal <- colorFactor(palette = "Set3",
                        domain = open_space$OWNERSHIP)

size_pal <- colorNumeric(palette = "PuBuGn",
                         domain = open_space$ACRES)
```

Then, in your leaflet map, you can use the palette you've defined to 
set the color of a set of features.

```{r}
leaflet(open_space) |>
  addPolygons(fillColor = ~owner_pal(OWNERSHIP),
              color = "white",
              weight = 0.5,
              fillOpacity = 1)
```


## R (static)

In `ggplot`, you can specify the variable that will control the symbology 
within an `aes()` function. A color palette will be assigned by default.

```{r}
ggplot(open_space) +
  geom_sf(aes(fill = OWNERSHIP))
```

You can specify an `RColorBrewer` palette using the `scale_fill_brewer()` function.

```{r}
ggplot(open_space) +
  geom_sf(aes(fill = OWNERSHIP)) +
  scale_fill_brewer(palette = "Set3")
```



## QGIS

In QGIS, double-click on the symbol in the layers pane to open a 
symbology window. Use the drop-down menu at the top of the window
to change the method from "Single symbol" to "Categorized" or
"Graduated." Select a variable from the "Value" drop-down menu and
click the "Classify" button at the bottom of the window. You can
select a new color ramp by selecting from the "Color ramp"
drop-down menu.

```{r, echo=FALSE, out.width = '100%'}
here("week1",
     "examples",
     "qgis-gifs",
     "cat-vars.gif") |>
  knitr::include_graphics()
```

## ArcGIS

In ArcGIS, you can double-click on the symbol in the contents pane
to get to a symbology window. In the "Primary symbology" drop-down
menu, select "Unique values" for categorical variables or "Unclassed Colors"
for continuous variables. 

```{r, echo=FALSE, out.width = '100%'}
here("week1",
     "examples",
     "arcgis-gifs",
     "vars.gif") |>
  knitr::include_graphics()
```

# Styling your plot

You can also change the appearance of the plot itself.

## R (static)

In `ggplot`, you'll set the overall appearance of a plot using the
`theme` function. In the example below, I'm removing the tick marks
and axis text, setting the panel background to be light blue, and setting
the grid lines (which are latitude and longitude lines in this case) to be
dotted, darker blue lines.

```{r}
ggplot(africa) +
  geom_sf() +
  theme(axis.text = element_blank(),
        axis.ticks = element_blank(),
        panel.background = element_rect(fill = "lightblue"),
        panel.grid.major = element_line(color = "blue",
                                        linetype = "dotted"))
```

Rather than messing around with all the details you can set in the `theme`
function, you can also use one of many pre-defined themes. Most of 
these were developed for use with scatter plots rather than maps.

```{r}
ggplot(africa) +
  geom_sf() +
  theme_light()
```

```{r}
ggplot(africa) +
  geom_sf() +
  theme_linedraw()
```

For maps, you often don't want to show grid lines or axis text. 
`theme_void` will remove all of this from your plot.

```{r}
ggplot(africa) +
  geom_sf() +
  theme_void()
```

The ggthemes package has a number of interesting pre-defined themes. Again, most 
of them were developed for scatter plots. Here is a plot in the Wall Street Journal 
house style.

```{r}
library(ggthemes)

ggplot(africa) +
  geom_sf() +
  theme_wsj()
```

`ggthemes` also has a function called `theme_map` that gives you a nice, clean-looking
map. You'll notice that it looks a lot like `theme_void`. The main difference is 
in how the legend appears (not relevant in this example that doesn't
have a legend).

```{r}
ggplot(africa) +
  geom_sf() +
  theme_map()
```



## QGIS

In QGIS, you can create a map layout by selecting "New Print Layout..." from
the "Project" menu. This will open a layout in a new window. From the layout
window, select "Add Map" from the "Add Item" menu to add a map to your layout.

```{r, echo=FALSE, out.width = '100%'}
here("week1",
     "examples",
     "arcgis-gifs",
     "make-layout.gif") |>
  knitr::include_graphics()
```

Right-click on the map frame to open the "Item properties" tab,
which includes settings for displaying a grid and setting the
map's background color.

```{r, echo=FALSE, out.width = '100%'}
here("week1",
     "examples",
     "qgis-gifs",
     "style-layout.gif") |>
  knitr::include_graphics()
```

## ArcGIS

In ArcGIS, you can create a map layout by selecting "New Layout" on the "Insert"
tab and adding a map frame to it.

```{r, echo=FALSE, out.width = '100%'}
here("week1",
     "examples",
     "arcgis-gifs",
     "make-layout.gif") |>
  knitr::include_graphics()
```

You can find options to style the map pane by double-clicking on it. You can also add
grid lines.

```{r, echo=FALSE, out.width = '100%'}
here("week1",
     "examples",
     "arcgis-gifs",
     "style-layout.gif") |>
  knitr::include_graphics()
```

# Adding a legend

A legend is often (but not always) necessary for your audience to understand
your map.

## R (interactive)

In `leaflet` legends can only be used for colors. If the data you want in
your legend are in separate layers, the easiest approach to creating 
a legend is to specify colors manually.

```{r, warning=FALSE}
leaflet() |>
  addPolygons(data = texas, 
              popup = ~NAME,
              stroke = FALSE,
              fillOpacity = 1,
              fillColor = "white") |>
  addCircleMarkers(data = TX_cemeteries,
                   popup = ~FULLNAME,
                   stroke = FALSE,
                   fillColor = "black",
                   radius = 4,
                   opacity = 0.7) |>
  addCircleMarkers(data = TX_golf,
                   popup = ~FULLNAME,
                   stroke = FALSE,
                   fillColor = "darkgreen",
                   radius = 4,
                   opacity = 0.7) |>
  addLegend(position = "bottomleft",
            colors = c("black", "darkgreen"),
            labels = c("Cemetery", "Golf course"),
            opacity = 0.7)
```

If you have a color palette mapped to a variable and you want a 
legend that refers to that color palette, you can pass the palette 
and the name of the variable into the `addLegend` function.

```{r, warning=FALSE}
size_pal <- colorNumeric(palette = "PuBuGn",
                         domain = open_space$ACRES)

leaflet(open_space) |>
  addPolygons(popup = ~SITE_NAME,
              stroke = FALSE,
              fillOpacity = 1,
              fillColor = ~size_pal(ACRES)) |>
  addLegend(pal = size_pal,
            values = ~ACRES,
            title = "Park size (acres)",
            position = "bottomright")
```

## R (static)

To include an item in a legend for `ggplot`, you specify its appearance a little differently.
In the example below, I replace `linetype = "dotted"` with `aes(linetype = "Railroad")`
so that the item will appear in a legend labeled as "Railroad." Then I add 
the function `scale_linetype_manual` to create a legend based on line type, and
I specify the line type for railroads within that function.

I do something similar to create a color-based legend for cemeteries.

Note that this is actually creating two separate legends (one for line types and one
for colors) so I'm using the `legend.title` argument in the `theme` function 
to remove all the legend titles.

```{r}
ggplot() +
  geom_sf(data = texas,
          color = NA,
          fill = "cornsilk") +
  geom_sf(data = TX_rails,
          color = "black",
          linewidth = 0.5,
          aes(linetype = "Railroad")) +
  geom_sf(data = TX_cemeteries,
          size = 4,
          shape = 18,
          aes(color = "Cemetery"),
          alpha = 0.5) +
  scale_color_manual(values = "darkgreen") +
  scale_linetype_manual(values = "dotted") +
  theme_map() +
  theme(legend.title = element_blank())
```


If you have a color palette mapped to a variable, ggplot will 
automatically add a legend, which you can customize further
in the `scale_fill_brewer()` function.

The `theme` function can also change the position of the legend.

```{r}
ggplot(open_space) +
  geom_sf(aes(fill = OWNERSHIP)) +
  scale_fill_brewer(palette = "Set3", 
                    name = "Property owner") +
  theme_map() +
  theme(legend.position = c(0.6, 0),
        legend.background = element_rect(fill = alpha("white", 0.7)))
```




## QGIS

In QGIS, add a legend by selecting "Add Legend" from the "Add Item" menu in the
layout window. In the "Item Properties" pane for the legend, you can re-order, 
rename, or remove legend items.

```{r, echo=FALSE, out.width = '100%'}
here("week1",
     "examples",
     "qgis-gifs",
     "legend.gif") |>
  knitr::include_graphics()
```

## ArcGIS

In ArcGIS, you can use the "Legend" button on the "Insert" tab to add a legend
to your map. You can rename legend items by renaming the layer in the contents
pane. You can remove an item from the legend (without removing the associated 
layer from the map) by unchecking its box in the Legend group of the contents pane.

```{r, echo=FALSE, out.width = '100%'}
here("week1",
     "examples",
     "arcgis-gifs",
     "legend.gif") |>
  knitr::include_graphics()
```

# Setting map extents

In general, the map extents will be set to include all the data in your map. 
You may want to include less or more than this.

## R (interactive)

With `leaflet` you can set the initial Zoom level, the initial map center, 
the minimum zoom level, and the map extents beyond which a user can't pan away.

`setView` let's you define the initial center of the map and the map's initial
zoom level. Zoom level can be values between 0 and 20 or so. A value of 0 is 
appropriate for representing the entire world and a value of 20 us appropriate
for showing a single building or parcel. 

Within the initial `leaflet` function that sets up the map, you can specify
`minZoom` within `options = leafletOptions()` to keep the user from 
zooming out beyond a certain zoom level.

You can also use setMaxBounds to keep the user from panning awat from your 
initial map extents. You need to specify minimum and maximum latitude values
(`lat1` and `lat2`) and minimum and maximum longitude values (`lng1` and `lng2`).
The `st_bbox` function in the `sf` package can be a useful way to get the values
for a bounding box around a specific layer.


```{r, warning=FALSE}
TX_bbox <- st_bbox(texas)

leaflet(options = leafletOptions(minZoom = 6)) |>
  setView(lng = -99.88829,
          lat = 32.75079,
          zoom = 7) |>
  setMaxBounds(lng1 = as.numeric(TX_bbox["xmin"]),
               lng2 = as.numeric(TX_bbox["xmax"]),
               lat1 = as.numeric(TX_bbox["ymin"]),
               lat2 = as.numeric(TX_bbox["ymax"])) |>
  addPolygons(data = texas, 
              popup = ~NAME,
              stroke = FALSE,
              fillOpacity = 1,
              fillColor = "white") |>
  addPolylines(data = TX_rails, 
               popup = ~FULLNAME, 
               color = "gray",
               weight = 1,
               opacity = 1) 
```

## R (static)

In `ggplot` you can set the map extents using the `coord_sf()` function
in the `ggspatial` package. In the example below, I'm limiting my 
map of African countries to show only the area between zero and twenty
degrees latitude and between zero and twenty degrees longitude.

```{r}
ggplot(africa) +
  geom_sf() +
  annotation_north_arrow(location = "tr",
                         style = north_arrow_minimal) +
  coord_sf(xlim = c(0, 20),
           ylim = c(0, 20)) +
  theme_map()
```



## QGIS

In the "Layouts" window in QGIS, select the map frame, then click the button
for "you can click the "Activate" button to activate
your map frame."Move Item Content." This will allow you to pan and zoom the map 
within the layout.

```{r, echo=FALSE, out.width = '100%'}
here("week1",
     "examples",
     "qgis-gifs",
     "extent.gif") |>
  knitr::include_graphics()
```

## ArcGIS

From the "Layouts" tab in ArcGIS, you can click the "Activate" button to activate
your map frame. This will allow you to pan and zoom the map within the layout.
When you are satisfied, click the "Layout" button and then the "Close Activation"
button.

```{r, echo=FALSE, out.width = '100%'}
here("week1",
     "examples",
     "arcgis-gifs",
     "map-extent.gif") |>
  knitr::include_graphics()
```

# Adding a north arrow

A north arrow is not always necessary, but it can be helpful depending on your audience
and on the purpose of your map.

## R (static)

The `ggspatial` package includes an `annotation_north_arrow` function that will 
add a north arrow to your map. It includes the following arguments:

* `location` indicates where the north arrow will be displayed. Options
include `tl` (top left), `tr` (top right), `bl` (bottom left), and `br` 
(bottom right)
* `style` indicates the arrow style. Options include:
    * north_arrow_orienteering
    * north_arrow_fancy_orienteering
    * north_arrow_minimal
    * north_arrow_nautical

```{r}
ggplot(africa) +
  geom_sf() +
  annotation_north_arrow(location = "tr",
                         style = north_arrow_minimal) +
  theme_map()
```

## QGIS

You can add a north arrow by selecting "Add North Arrow" from the "Add Item" 
menu in the Layout window. The item properties window includes options for
different north arrow styles.

```{r, echo=FALSE, out.width = '100%'}
here("week1",
     "examples",
     "qgis-gifs",
     "north.gif") |>
  knitr::include_graphics()
```

## ArcGIS

You can add a north arrow using the "North Arrow" button on the "Insert" tab.

```{r, echo=FALSE, out.width = '100%'}
here("week1",
     "examples",
     "arcgis-gifs",
     "north-arrow.gif") |>
  knitr::include_graphics()
```

# Adding a scale bar

A scale bar may be helpful to give your reader a sense of distances.

## R (static)

The `ggspatial` package includes an `annotation_scale` function that will 
add a scale bar to your map. It includes the following arguments:

* `location` indicates where the scale bar will be displayed. Options
include `tl` (top left), `tr` (top right), `bl` (bottom left), and `br` 
(bottom right)
* `style` indicates the scale bar style: either `"bars"` or `"ticks"`.

```{r}
ggplot(open_space) +
  geom_sf() +
  annotation_scale(location = "br",
                   style = "ticks") +
  theme_map()
```

## QGIS

You can add a scale bar by selecting "Add Scale Bar" from the "Add Item" 
menu in the Layout window. 

```{r, echo=FALSE, out.width = '100%'}
here("week1",
     "examples",
     "qgis-gifs",
     "scale.gif") |>
  knitr::include_graphics()
```

## ArcGIS

You can add a scale bar using the "Scale Bar" button on the "Insert" tab.

```{r, echo=FALSE, out.width = '100%'}
here("week1",
     "examples",
     "arcgis-gifs",
     "scale-bar.gif") |>
  knitr::include_graphics()
```

# Adding annotation

The easiest way to annotate a static map may be to bring it into illustrator, but you
can also do it within your GIS program.

## R (interactive)

You could just embed your leaflet map within an RMarkdown file and include
text outside the code chunk. If you want to add annotation to the map itself,
you can hack a legend to act as map annotation.

```{r, warning=FALSE}
leaflet() |>
  addPolygons(data = texas, 
              popup = ~NAME,
              stroke = FALSE,
              fillOpacity = 1,
              fillColor = "white") |>
  addCircleMarkers(data = TX_cemeteries,
                   popup = ~FULLNAME,
                   stroke = FALSE,
                   fillColor = "black",
                   radius = 4,
                   opacity = 0.7) |>
  addCircleMarkers(data = TX_golf,
                   popup = ~FULLNAME,
                   stroke = FALSE,
                   fillColor = "darkgreen",
                   radius = 4,
                   opacity = 0.7) |>
  addLegend(position = "bottomleft",
            colors = c("black", "darkgreen"),
            labels = c("Cemetery", "Golf course"),
            opacity = 0.7) |>
  addLegend(position = "bottomright",
            colors = c("white", "white"),
            opacity = 0,
            labels = c("Source: Census TIGER files (landmarks)",
                       "Here is another comment about this map.")) |>
  addLegend(position = "topright",
            title = "Golf Courses and Cemeteries in Texas",
            colors = "white",
            opacity = 0,
            labels="")
```

## R (static)

The `annotate` function will place text on your map. You need to specify
the following arguments:

* `geom`: Set `geom = "text"` to place text on the map.
* `x`, `y`: The x- and y-coordinates of the location the text 
should be placed, in the coordinate system of the map (if you're 
plotting the map without grid lines, you might want to make a quick 
plot that shows them so you can find the right values to place your annotation).
* `label`: The text you want to place. There is no text wrapping; you can use
`\n` within your next string to move to a new line.

The following optional arguments are also helpful:

* `hjust`: The horizontal justification of your text. The default is 
0.5, which indicates centered text (and x-coordinate you've used
to place the text will be for the middle of the text). A value of 0 
will give you left-justified text, and a value of 1 will give you
right-justified text.
* `vjust`: The vertical justification of your text. A value of 
0.5 means the y-coordinate you've specified is for the center
of the text. A value of 0 means the y-coordinate is for the
bottom of the text. A value of 1 means the y-coordiate is for the top of 
the text.

You can also use the `ggtitle` function to add a title and (optionally) a 
subtitle to your map.

```{r}
ggplot(open_space) +
  geom_sf() +
  annotate(geom = "text",
           x = -71.1,
           y = 42.25,
           label = "This is a map of\nopen space in Boston",
           hjust = 0,
           vjust = 1) +
  ggtitle(label = "Open Space in Boston",
          subtitle = "VIS 2128")
```

## QGIS

You can add text to your map by selecting "Add Label" from the "Add Item" 
menu in the Layout window. In the Item Properties pane, you can edit
the text box content and set the font.

```{r, echo=FALSE, out.width = '100%'}
here("week1",
     "examples",
     "qgis-gifs",
     "text.gif") |>
  knitr::include_graphics()
```

## ArcGIS

You can add a text box by selecting "Text" from the "Graphic" drop-down menu on the
"Insert" tab. You can edit the text box content and text style by double-clicking
on the text box or right-clicking and selecting "Properties."

```{r, echo=FALSE, out.width = '100%'}
here("week1",
     "examples",
     "arcgis-gifs",
     "text-box.gif") |>
  knitr::include_graphics()
```

# Saving your map

Please don't just take screenshots of the maps you create in a GIS program. You can 
save them to a variety of file types.

## R (interactive)

If your interactive map is embedded in an RMarkdown file, you can just knit the
file to save it as an html file.

If you want a stand-alone html file that's just your map, you can
pipe the map in the `saveWidget` function in the `htmlwidgets` package.

```{r, warning=FALSE}
leaflet() |>
  addPolygons(data = texas, 
              popup = ~NAME,
              stroke = FALSE,
              fillOpacity = 1,
              fillColor = "white") |>
  saveWidget(file = "texas.html")

```

## R (static)

The `ggsave` function give you a nice easy way to save a `ggplot` map. By default,
it saves your most recent plot. You should specify the following arguments:

* `filename`: The name of the file. `ggsave` will guess the file format (e.g. jpg, png, pdf)
based on the filename's extension. You can pipe the path from the `here()` function 
to make sure you end up in the right directory.
* `width`, `height`: The dimensions of the image you want to save.
* `units`: The units of the dimensions you've specified, one of:
   * `"in"` for inches
   * `"cm"` for centimeters
   * `"mm"` for millimeters
   * `"px"` for pixels
   
For raster images (e.g. jpg or png), you should also specify the resolution with `dpi=`.

```{r}
here("week1", 
     "examples",
     "open-space.pdf") |>
  ggsave(width = 11,
         height = 8.5,
         units = "in")
```



## QGIS

The layout window in QGIS will have buttons to

* Print the layout
* Save the layout as an image
* Save the layout as a PDF

```{r, echo=FALSE, out.width = '100%'}
here("week1",
     "examples",
     "qgis-gifs",
     "save.gif") |>
  knitr::include_graphics()
```

## ArcGIS

Save your layout by selecting "Export Layout" from share tab. Note that
you can save as a PDF or as an AIX file that you can work with futher in 
Adobe Illustrator.

```{r, echo=FALSE, out.width = '100%'}
here("week1",
     "examples",
     "arcgis-gifs",
     "save-layout.gif") |>
  knitr::include_graphics()
```